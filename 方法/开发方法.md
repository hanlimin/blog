### 前言

​		软件工程的方法有很多方面的意义。包括项目管理，分析，设计，程序的编写，测试和质量控制。

​		[软件设计](https://zh.wikipedia.org/wiki/软件设计)方法可以区别为**重量级的方法**和**轻量级的方法**。重量级的方法中产生大量的正式[文档](https://zh.wikipedia.org/w/index.php?title=软件开发文档&action=edit&redlink=1)。

​		著名的重量级开发方法包括[ISO 9000](https://zh.wikipedia.org/wiki/ISO_9000)，[CMM](https://zh.wikipedia.org/wiki/CMM)，和[统一软件开发过程](https://zh.wikipedia.org/wiki/Rational統一過程)（RUP）。

​		轻量级的开发过程没有对大量正式文档的要求。著名的轻量级开发方法包括[极限编程](https://zh.wikipedia.org/wiki/极限编程)（XP）和[敏捷过程](https://zh.wikipedia.org/w/index.php?title=敏捷过程&action=edit&redlink=1)（Agile Processes）。

​		根据《新方法学》这篇文章的说法，**重量级方法**呈现的是一种“防御型”的姿态。在应用“重量级方法”的软件组织中，由于软件项目经理不参与或者很少参与程序设计，无法从细节上把握项目进度，因而会对项目产生“恐惧感”，不得不要求程序员不断撰写很多“[软件开发文档](https://zh.wikipedia.org/w/index.php?title=软件开发文档&action=edit&redlink=1)”。而**轻量级方法**则呈现“进攻型”的姿态，这一点从XP方法特别强调的四个准则—“沟通、简单、反馈和勇气”上有所体现。当前有一些人认为，“重量级方法”适合于大型的软件团队（数十人以上）使用，而“轻量级方法”适合小型的软件团队（几人、十几人）使用。当然，关于**重量级方法**和**轻量级方法**的优劣存在很多争论，而各种方法也在不断进化中。

​		一些方法论者认为人们在开发中应当严格遵循并且实施这些方法。但是一些人并不具有实施这些方法的条件。实际上，采用何种方法开发软件取决于很多因素，同时受到环境的制约。



### 边做边改模型（Build-and-Fix Model）

​		在这种模型中，既没有规格说明，也没有经过设计，软件随着客户的需要一次又一次地不断被修改。

​		在这个模型中，开发人员拿到项目立即根据需求编写程序，调试通过后生成软件的第一个版本。在提供给用户使用后，如果程序出现错误，或者用户提出新的要求，开发人员重新修改代码，直到用户满意为止。

​		这是一种类似作坊的开发方式，对编写几百行的小程序来说还不错，但这种方法对任何规模的开发来说都是不能令人满意的，其主要问题在于：

　　1） 缺少规划和设计环节，软件的结构随着不断的修改越来越糟，导致无法继续修改；

　　2） 忽略需求环节，给软件开发带来很大的风险；

　　3） 没有考虑测试和程序的可维护性，也没有任何文档，软件的维护十分困难。

### 瀑布模型（Waterfall Model）

​		1970年[温斯顿·罗伊斯](https://wiki.mbalib.com/w/index.php?title=温斯顿·罗伊斯&action=edit)（Winston Royce）提出了著名的“瀑布模型”，直到80年代早期，它一直是唯一被广泛采用的[软件开发模型](https://wiki.mbalib.com/wiki/软件开发模型)。

​		瀑布模型核心思想是按工序将问题化简，将功能的实现与设计分开，便于分工协作，即采用结构化的分析与设计方法将逻辑实现与物理实现分开。将软件生命周期划分为需求分析、软件设计、程序编写、软件测试和运行维护等五个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。

<img src="../imgs/Waterfall_model.png" height="400px">

​		瀑布流的特点是流程严谨，次序严格，步骤成功作为衡量进度的方法，所以工作成果容易量化，但是缺陷也很明显，就是灵活性较差，需求变动的代价高昂。

### 快速原型模型（Rapid Prototype Model）

​		快速原型模型的第一步是建造一个快速原型，实现客户或未来的用户与系统的交互，用户或客户对原型进行评价，进一步细化待开发软件的需求。通过逐步调整原型使其满足客户的要求，开发人员可以确定客户的真正需求是什么；第二步则在第一步的基础上开发客户满意的软件产品。

<img src="../imgs/rapid_prototype_model.gif" height="400px">

​		显然，快速原型方法可以克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险，具有显著的效果。

​		快速原型的关键在于尽可能快速地建造出软件原型，一旦确定了客户的真正需求，所建造的原型将被丢弃。因此，原型系统的内部结构并不重要，重要的是必须迅速建立原型，随之迅速修改原型，以反映客户的需求。

### 增量模型（Incremental Model）

　　与建造大厦相同，软件也是一步一步建造起来的。在增量模型中，软件被作为一系列的增量构件来设计、实现、集成和测试，每一个构件是由多种相互作用的模块所形成的提供特定功能的代码片段构成。

<img src="../imgs/incremental_model.jpg">

　　增量模型在各个阶段并不交付一个可运行的完整产品，而是交付满足客户需求的一个子集的可运行产品。整个产品被分解成若干个构件，开发人员逐个构件地交付产品，这样做的好处是软件开发可以较好地适应变化，客户可以不断地看到所开发的软件，从而降低开发风险。但是，增量模型也存在以下缺陷：

　　1） 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。

　　2） 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而是[软件过程](https://wiki.mbalib.com/wiki/软件过程)的控制失去整体性。

　　在使用增量模型时，第一个增量往往是实现基本需求的[核心产品](https://wiki.mbalib.com/wiki/核心产品)。核心产品交付用户使用后，经过评价形成下一个增量的开发计划，它包括对核心产品的修改和一些新功能的发布。这个过程在每个增量发布后不断重复，直到产生最终的完善产品。

　　例如，使用增量模型开发字处理软件。可以考虑，第一个增量发布基本的文件管理、编辑和文档生成功能，第二个增量发布更加完善的编辑和文档生成功能，第三个增量实现拼写和文法检查功能，第四个增量完成高级的页面布局功能。

### 螺旋模型（Spiral Model）

　　1988年，[巴利·玻姆](https://wiki.mbalib.com/wiki/巴利·玻姆)[Barry Boehm](https://wiki.mbalib.com/wiki/Barry_Boehm)正式发表了软件系统开发的“螺旋模型”，它将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的[风险分析](https://wiki.mbalib.com/wiki/风险分析)，特别适合于大型复杂的系统。

<img src="../imgs/spiral_model.png">

　　螺旋模型沿着螺线进行若干次迭代，图中的四个象限代表了以下活动：

　　1） 制定计划：确定软件目标，选定实施方案，弄清项目开发的限制条件；

　　2） 风险分析：分析评估所选方案，考虑如何识别和消除风险；

　　3） 实施工程：实施软件开发和验证；

　　4） 客户评估：评价开发工作，提出修正建议，制定下一步计划。

　　螺旋模型由风险驱动，强调可选方案和约束条件从而支持软件的重用，有助于将[软件质量](https://wiki.mbalib.com/wiki/软件质量)作为特殊目标融入产品开发之中。但是，螺旋模型也有一定的限制条件，具体如下：

　　1） 螺旋模型强调风险分析，但要求许多客户接受和相信这种分析，并做出相关反应是不容易的，因此，这种模型往往适应于内部的大规模软件开发。

　　2） 如果[执行风险](https://wiki.mbalib.com/wiki/执行风险)分析将大大影响项目的利润，那么进行风险分析毫无意义，因此，螺旋模型只适合于大规模软件项目。

　　3） 软件开发人员应该擅长寻找可能的风险，准确地分析风险，否则将会带来更大的风险

　　一个阶段首先是确定该阶段的目标，完成这些目标的选择方案及其约束条件，然后从风险角度分析方案的开发策略，努力排除各种潜在的风险，有时需要通过建造原型来完成。如果某些风险不能排除，该方案立即终止，否则启动下一个开发步骤。最后，评价该阶段的结果，并设计下一个阶段。

#### 优势

- 通过原型的创建，使软件开发在每个迭代的最初明确方向；
- 通过风险分析，最大程度地降低软件彻底失败造成损失的可能性；
- 在每个迭代阶段植入[软件测试](https://zh.wikipedia.org/wiki/软件测试)，使每个阶段的质量得到保证；
- 整体过程具备很高的灵活性，在开发过程的任何阶段自由应对变化；
- 每个迭代阶段累计开发成本，使支出状况容易掌握；
- 通过对用户反馈的采集，与用户沟通，以保证用户需求的最大实现；

#### 缺陷

- 过分依赖风险分析经验与技术，一旦在风险分析过程中出现偏差将造成重大损失；
- 过于灵活的开发过程不利于已经签署合同的客户与开发者之间的协调；
- 由于只适用大型软件，过大的[风险管理](https://zh.wikipedia.org/wiki/风险管理)支出会影响客户的最终收益；

### 迭代模型

​		在迭代式开发方法中，整个开发工作被组织为一系列的短小的、固定长度（如3周）的小项目，被称为一系列的**迭代**。每一次迭代都包括了需求分析、设计、实现与测试。采用这种方法，开发工作可以在需求被完整地确定之前启动，并在一次迭代中完成系统的一部分功能或业务逻辑的开发工作。再通过客户的反馈来细化需求，并开始新一轮的迭代。

#### 优点

从商业角度考虑：

- 迭代模型能够更快的开发出一个可用的版本，可以尽早的推广，占领市场

从软件开发角度看优势：

- 降低了在一个增量上的开支风险。如果开发人员重复某个迭代，那么损失只是这一个开发有误的迭代的花费。

- 降低了产品无法按照既定进度进入市场的风险，每一个迭代都是一个可用的版本，基本上每一个迭代都会给客户使用，可以不断验证我们开发功能是否符合客户要求

- 加快了整个开发工作的进度。因为每个迭代都会专注于开发某一个或某几个功能，开发人员清楚问题的焦点所在，他们的工作会更有效率。

- 由于用户的需求并不能在一开始就作出完全的界定，它们通常是在后续阶段中不断细化的（也可以通过观察客户反馈，细化需求，挖掘需求，瀑布模型就没有这个优势）。因此，迭代过程这种模式使适应需求的变化会更容易些。

### 敏捷模型

敏捷开发模式是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于"非敏捷"，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重做为软件开发中人的作用。
敏捷开发以用户的需求进化为核心，采用迭代、循序渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试，具备可视、可集成和可运行使用的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。

#### 敏捷软件开发宣言

 我们一直在实践中探寻更好的软件开发方法，身体力行的同时也帮助他人。由此我们建立了如下价值观：

个体和互动 高于 流程和工具
工作的软件 高于 详尽的文档
客户合作 高于 合同谈判
响应变化 高于 遵循计划

也就是说，尽管右项有其价值，我们更重视左项的价值。

#### 敏捷软件的十二条原则

- 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。

- 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。

- 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。

- 业务人员和开发人员必须相互合作，项目中的每一天都不例外。

- 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。

- 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。

- 可工作的软件是进度的首要度量标准。

- 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。

- 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。

- 以简洁为本，它是极力减少不必要工作量的艺术。

- 最好的架构、需求和设计出自自组织团队。

- 团队定期地反思如何能提高成效，并依此调整自身的举止表现。

#### 优点

1、迭代快，开发周期短；
2、不再耗费大量的时间来写文档，而是人与人面对面交流，只写一些必要的文档；
3、分工详细，每天都输出成果，客户能够看得到，会信任项目团队；
4、沟通多，容易发现问题，同时能够激起团队的协作、奋斗；

####  缺点

1、人与人之间的信任是非常重要的环节，但是这个比较难完成，技术团队的成员可能技术能力差别大，同时也有互相竞争，又或者是项目团队的成员有所保留，不愿意这样的沟通；
2、团队在开发期间的任务多、压力大，需要时刻保持“兴奋”，一般很难做到

#### 实践

##### Test-Driven Development，测试驱动开发

​		它是敏捷开发的最重要的部分。在ThoughtWorks，我们实现任何一个功能都是从[测试](https://wiki.mbalib.com/wiki/测试)开始，首先对业务需求进行分析，分解为一个一个的Story，记录在Story Card上。然后两个人同时坐在电脑前面，一个人依照Story，从业务需求的角度来编写测试代码，另一个人看着他并且进行思考，如果有不同的意见就会提出来进行讨论，直到达成共识，这样写出来的测试代码就真实反映了业务功能需求。接着由另一个人控制键盘，编写该测试代码的实现。如果没有测试代码，就不能编写功能的实现代码。先写测试代码，能够让开发人员明确目标，就是让测试通过。

##### Behavior-driven development，行为驱动开发

​		通过与利益相关者的讨论取得对预期的软件行为的清醒认识。它通过用自然语言书写非程序员可读的测试用例扩展了测试驱动开发方法。行为驱动开发人员使用混合了领域中统一的语言的母语语言来描述他们的代码的目的。这让开发者得以把精力集中在代码应该怎么写，而不是技术细节上，而且也最大程度的减少了将代码编写者的技术语言与商业客户、用户、利益相关者、项目管理者等的领域语言之间来回翻译的代价。

###### 实践

- 确立不同利益相关者要实现的远景目标
- 使用[特性注入](https://zh.wikipedia.org/w/index.php?title=特性注入&action=edit&redlink=1)方法绘制出达到这些目标所需要的特性
- 通过[由外及内的软件开发](https://zh.wikipedia.org/w/index.php?title=由外及内的软件开发&action=edit&redlink=1)方法，把涉及到的利益相关者融入到实现的过程中
- 使用例子来描述应用程序的行为或代码的每个单元
- 通过自动运行这些例子，提供快速反馈，进行[回归测试](https://zh.wikipedia.org/wiki/回归测试)
- 使用“应当(should)”来描述软件的行为，以帮助阐明代码的职责，以及回答对该软件的功能性的质疑
- 使用“确保(ensure)”来描述软件的职责，以把代码本身的效用与其他单元(element)代码带来的边际效用中区分出来。
- 使用[mock](https://zh.wikipedia.org/wiki/Mock)作为还未编写的相关代码模块的替身

##### Continuous Integration，持续集成

​		在以往的软件开发过程中，集成是一件很痛苦的事情，通常很长时间才会做一次集成，这样的话，会引发很多问题，比如 build未通过或者单元测试失败。敏捷开发中提倡持续集成，一天之内集成十几次甚至几十次，如此频繁的集成能尽量减少冲突，由于集成很频繁，每一次集成的改变也很少，即使集成失败也容易定位错误。一次集成要做哪些事情呢？它至少包括：获得所有[源代码](https://wiki.mbalib.com/wiki/源代码)、编译源代码、运行所有测试，包括[单元测试](https://wiki.mbalib.com/wiki/单元测试)、功能测试等；确认编译和测试是否通过，最后发送报告。当然也会做一些其它的任务，比如说代码分析、测试覆盖率分析等等。在我们公司里，开发人员的桌上有一个火山灯用来标志集成的状态，如果是黄灯，表示正在集成；如果是绿灯，表示上一次集成通过，开发人员在这时候获得的代码是可用而可靠的；如果显示为红灯，就要小心了，上一次集成未通过，需要尽快定位失败原因从而让灯变绿。在[持续集成](https://wiki.mbalib.com/wiki/持续集成)上，我们公司使用的是自己开发的产品CruiseControl。

##### Refactoring，重构

​		相信大家对它都很熟悉了，有很多很多的书用来介绍重构，最著名的是Martin的《重构》，Joshua的《从重构到模式》等。重构是在不改变系统外部行为下，对内部结构进行整理优化，使得代码尽量简单、优美、可扩展。在以往开发中，通常是在有需求过来，现在的系统架构不容易实现，从而对原有系统进行重构；或者在开发过程中有剩余时间了，对现在代码进行重构整理。但是在敏捷开发中，重构贯穿于整个开发流程，每一次开发者check in代码之前，都要对所写代码进行重构，让代码达到clean code that works。值得注意的是，在重构时，每一次改变要尽可能小，用单元测试来保证重构是否引起冲突，并且不只是对实现代码进行重构，如果测试代码中有重复，也要对它进行重构。

##### Pair-Programming，结对编程

　	在敏捷开发中，做任何事情都是Pair的，包括分析、写测试、写实现代码或者重构。Pair做事有很多好处，两个人在一起探讨很容易产生思想的火花，也不容易走上偏路。在我们公司，还有很多事都是Pair来做，比如Pair学习，Pair翻译，Pair做PPT，关于这个话题，钱钱同学有一篇很有名的文章对它进行介绍，名为Pair Programming (结对编程)。

##### Stand up，站立会议

　　每天早上，项目组的所有成员都会站立进行一次会议，由于是站立的，所以时间不会很长，一般来说是15-20分钟。会议的内容并不是需求分析、任务分配等，而是每个人都回答三个问题：1. 你昨天做了什么？2. 你今天要做什么？ 3. 你遇到了哪些困难？站立会议让团队进行交流，彼此相互熟悉工作内容，如果有人曾经遇到过和你类似的问题，那么在站立会议后，他就会和你进行讨论。

Frequent Releases，小版本发布

　　在敏捷开发中，不会出现这种情况，拿到需求以后就闭门造车，直到最后才将产品交付给客户，而是尽量多的产品发布，一般以周、月为单位。这样，客户每隔一段时间就会拿到发布的产品进行试用，而我们可以从客户那得到更多的反馈来改进产品。正因为发布频繁，每一个版本新增的功能简单，不需要复杂的设计，这样文档和设计就在很大程度上简化了。又因为简单设计，没有复杂的架构，所以客户有新的需求或者需求进行变动，也能很快的适应。

##### Minimal Documentation，较少的文档

　　其实敏捷开发中并不是没有文档，而是有大量的文档，即测试。这些测试代码真实的反应了客户的需求以及系统API 的用法，如果有新人加入团队，最快的熟悉项目的方法就是给他看测试代码，而比一边看着文档一边进行debug要高效。如果用书面文档或者注释，某天代码变化了，需要对这些文档进行更新。一旦忘记更新文档，就会出现代码和文档不匹配的情况，这更加会让人迷惑。而在敏捷中并不会出现，因为只有测试变化了，代码才会变化，测试是真实反应代码的。这时有人会问：代码不写注释行吗？一般来说好的代码不是需要大量的注释吗？其实简单可读的代码才是好的代码，既然简单可读了，别人一看就能够看懂，这时候根本不需要对代码进行任何注释。若你觉得这段代码不加注释的话别人可能看不懂，就表示设计还不够简单，需要对它进行重构。

##### Collaborative Focus，以合作为中心，表现为代码共享

　　在敏捷开发中，代码是归团队所有而不是哪些模块的代码属于哪些人，每个人都有权利获得系统任何一部分的代码然后修改它，如果有人看到某些代码不爽的话，那他能够对这部分代码重构而不需要征求代码作者的同意，很可能也不知道是谁写的这部分代码。这样每个人都能熟悉系统的代码，即使团队的人员变动，也没有风险。

##### Customer Engagement ，现场客户

　　敏捷开发中，客户是与开发团队一起工作的，团队到客户现场进行开发或者邀请客户到团队公司里来开发。如果开发过程中有什么问题或者产品经过一个迭代后，能够以最快速度得到客户的反馈。

##### Automated Testing ，自动化测试

　　为了减小人力或者重复劳动，所有的测试包括[单元测试](https://wiki.mbalib.com/wiki/单元测试)、功能测试或[集成测试](https://wiki.mbalib.com/wiki/集成测试)等都是自动化的，这对QA人员提出了更高的要求。他们要熟悉开发语言、自动化测试工具，能够编写自动化测试脚本或者用工具录制。我们公司在自动化测试上做了大量的工作，包括Selenium开源项目。

##### Adaptive Planning，可调整计划

　　敏捷开发中计划是可调整的，并不是像以往的开发过程中，需求分析->概要设计->详细设计->开发 ->测试->交付，每一个阶段都是有计划的进行，一个阶段结束便开始下一个阶段。而敏捷开发中只有一次一次的迭代，小版本的发布，根据客户反馈随时作出相应的调整和变化。

　　敏捷开发过程与传统的开发过程有很大不同，在这过程中，团队是有激情有活力的，能够适应更大的变化，做出更高质量的软件。

> 软件工程，https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B
>
> 敏捷软件开发宣言，https://agilemanifesto.org/iso/zhchs/manifesto.html
>
> 新方法学，https://www.martinfowler.com/articles/newMethodology.html，中译文：http://softwarepractitioner.org/translations/fowler/newMethodology.shtml
