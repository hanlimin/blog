---
title: 高级特性
date: "2020-12-10 23:10:25"
modifyDate: "2020-12-10 23:10:25"
draft: true
---
### PERFORMANCE SCHEMA使用

库中的表分为

- `setup_*`表提供对`actors`、`timers`、`instances`、`instrments`、`consumers`的配置信息。

- 当前事件
- 事件历史
- 汇总信息
- 对象创建历史

### 分区表

应对非常大的表时，使用分区能够将数据分成多个区域。

 前MySQL支持范围分区（RANGE），列表分区（LIST），哈希分区（HASH）以及KEY分区四种。

- RANGE

   在5.7版本之前，对于DATA和DATETIME类型的列，如果要实现分区裁剪，只能使用YEAR() 和TO_DAYS()函数，在5.7版本中，又新增了TO_SECONDS()函数。 

- LIST

   LIST分区只支持整形，非整形字段需要通过函数转换成整形. 

- HASH

   基于给定的分区个数，将数据分配到不同的分区，HASH分区只能针对整数进行HASH，对于非整形的字段只能通过表达式将其转换成整数.

- LINEAR HASH

   LINEAR HASH分区是HASH分区的一种特殊类型，与HASH分区是基于MOD函数不同的是，它基于的是另外一种算法。 

- KEY

  1. KEY分区允许多列，而HASH分区只允许一列。
  2. 如果在有主键或者唯一键的情况下，key中分区列可不指定，默认为主键或者唯一键，如果没有，则必须显性指定列。
  3. KEY分区对象必须为列，而不能是基于列的表达式。
  4. KEY分区和HASH分区的算法不一样，PARTITION BY HASH (expr)，MOD取值的对象是expr返回的值，而PARTITION BY KEY (column_list)，基于的是列的MD5值。

  ### 视图

  视图本身时一个虚拟表，不存放任何数据。视图优点：

  - 使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。
  - 使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。

  - 一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响

  ### 储存过程

  ```sql
  delimiter //
  CREATE PROCEDURE test(IN n INT)
  BEGIN
  -- code
  END;
  //
  ```

  ### 触发器

  ```sql
CREATE TRIGGER test_trigger
  BEFORE INSERT ON test
  BEGIN
  -- code
  END;
  ```
  
  ### 事件

  ```sql
CREATE EVENT test_event ON SCHEDULE EVERY 2 WEEK
  DO
BEGIN
  -- code
  END
  ```
  
  ### 游标
  
  MySQL在服务器端提供只读的、单向的游标，而且只能在储存过程或者更底层的客户端API中使用。游标指向的对象都是储存在临时表中而不是实际查询到的数据。它可以逐行指向查询结果，然后让程序做进一步的处理。

  

  ### 绑定变量

  从MySQL 4.1版本开始，就支持服务器端的绑定变量。当创建一个绑定变量SQL时，客户端向服务器端发送了一个SQL语句的原型。服务器端收到这个SQL语句框架后，解析并储存这个SQL语句的部分执行计划，返回给客户端一个SQL语句处理句柄。以后每次执行这类查询，客户端都指定使用这个句柄。

  - 使用二进制协议

  - SQL接口的绑定变量，可以直接使用SQL语句实现绑定变量

    ```sql
  set @sql := 'select * from test where id = ?';
    prepare stmt_fetch_test from @sql;
  set @id := '123';
    execute stmt_fetch_test using @id;
  ```

### 自定义函数

使用C语言实现自定义函数

### 插件

可以使用插件为MySQL增加各种功能。

### 字符集和校对

#### 创建对象时的默认设置

- 创建数据库的时候，将根据服务器上的`character_set_server`设置来设定该数据的默认字符集。
- 创建表的时候，将根据数据库的字符集设定指定这个表的字符集设定。
- 创建列的时候，将根据表的设定指定列的字符集设定。

#### 服务端和客户端通信时的设置

- 服务端总是假设客户端时按照`character_set_client`设置的字符来传输数据和SQL语句的。
- 当服务器收到客户端的SQL语句时，它先将其转换成字符集`character_set_connection`。它还使用这个配置来决定如何将数据转换成字符串。
- 当服务服务端返回数据或错误信息给客户端时，它会将其转换成`character_set_result`。

### 全文索引

只有MyISAM引擎支持全文索引。在MySQL 5.6版本后，InnoDB也开始支持全文索引。目前支持在CHAR、VARCHAR、TEXT类型的列上定义索引。

- 自然语言搜索

  通过MATCH AGAINST传递某个特定的字符串来进行检索。

- 布尔搜索

  可以为检索的字符串添加操作符来定制搜索。

  - `~ `，包含字符串的行rank值更低
  - `+`，行记录必须包含字符串
  - `-`，行记录不可以包含字符串
  - `*`，通配符

- 查询扩展模式

  这种模式是自然语言模式下的一个变种，会执行两次检索，第一次使用给定短语进行检索，第二次是结合第一次相关性比较高的行进行检索。

### 分布式（XA）事务

分布式事务能够让数据引擎级别的ACID可以扩展到数据库层面，甚至扩展到多个数据库之间，这需要通过两个阶段提交实现。XA事务中需要一个事务协调器来保证所有的事务参与者都完成了准备工作（第一阶段）。如果事务协调器收到了所有的参与者都准备好的消息，就会告诉所有的事务可以提交了，这是第二阶段。MySQL在这个XA事务过程中扮演一个参与者的角色，而不是协调者。在MySQL中有两种XA事务。一方面，MySQL可以参与到外部的分布式事务中；另一方面，还可以通过XA事务来协调储存引擎和二进制日志。

#### 内部XA事务

MySQL本身的插件式架构导致在内部需要XA事务。在MySQL中各个储存引擎是完全独立的，所以跨存储引擎的事务就需要一个外部的协调者。此外，二进制日志操作也可以看作一个独立的"存储引擎"。在存储引擎提交的同时，需要将提交信息写入二进制日志，这就是一个分布式事务。

#### 外部XA事务

MySQL能够作为参与者完成一个外部的分布式事务



