---
title: BIO
date: "2021-03-18 19:01:36"
modifyDate: "2021-03-18 19:01:36"
draft: true
---

# BIO

**阻塞 IO** 和 **非阻塞 IO**

这两个概念是程序级别的。主要描述的是程序请求操作系统 IO 操作后，如果 IO 资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有 IO 资源准备好了)

**同步 IO** 和 **非同步 IO**

这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求 IO 操作后，如果 IO 资源没有准备好，该如何应对相应程序的问题: 前者不响应，直到 IO 资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当 IO 资源准备好以后，再用事件机制返回给程序。

### 传统的 BIO 通信方式简介

以前大多数网络通信方式都是阻塞模式的，即:

- 客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。
- 服务器端同样的，当在处理某个客户端 A 发来的请求时，另一个客户端 B 发来的请求会等待，直到服务器端的这个处理线程完成上一个处理

### 传统的 BIO 的问题

- 同一时间，服务器只能接受来自于客户端 A 的请求信息；虽然客户端 A 和客户端 B 的请求是同时进行的，但客户端 B 发送的请求信息只能等到服务器接受完 A 的请求数据后，才能被接受。
- 由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。

### 多线程方式 - 伪异步方式

上面说的情况是服务器只有一个线程的情况，通过使用多线程技术来解决这个问题:

- 当服务器收到客户端 X 的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端 Y 的请求。
- 客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式/观察模式(等其他设计模式)通知主线程。

但是使用线程来解决这个问题实际上是有局限性的:

- 虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知 `accept()` 的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来。
- 在 linux 系统中，可以创建的线程是有限的。我们可以通过 `cat /proc/sys/kernel/threads-max` 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU 切换所需的时间也就越长，用来处理真正业务的需求也就越少。
- 创建一个线程是有较大的资源消耗的。JVM 创建一个线程的时候，即使这个线程不做任何的工作，JVM 都会分配一个堆栈空间。这个空间的大小默认为 128K，你可以通过 `-Xss` 参数进行调整。当然还可以使用 `ThreadPoolExecutor` 线程池来缓解线程的创建问题，但是又会造成 `BlockingQueue` 积压任务的持续增加，同样消耗了大量资源。
- 另外，如果应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。那么，如果你真想单纯使用线程解决阻塞的问题，那么你自己都可以算出来您一个服务器节点可以一次接受多大的并发了。看来，单纯使用线程解决这个问题不是最好的办法。
