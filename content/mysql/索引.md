## 索引

### 作用

- 大大减少服务器需要扫描的数据量
- 可以帮助服务器避免排序和临时表
- 可以将随机IO变为顺序IO

### 索引类型

#### B-Tree

- 节点内包含一个属性`x.n`代表节点内关键字个数
- 节点内关键字以非递减存放
- 属性`x.leaf`，一个布尔值，若当前节点是叶节点则为`TRUE`，若为内部节点则为`FALSE`
- 每个节点内包含`n+1`个指向其孩子的指针
- 关键字 x. $key_i$ 对存储在各子树中的关键字范围加以分割
- 每个叶节点都具有相同的深度，即树的高度h
- 节点包含的键值数量上下界，这个范围使用一个固定数字`t>=2`来描述，这个数字称之为这个B-Tree的度。

  - 除根结点外每个节点至少有`t-1`个关键字，除根节点外每个节点至少有`t`个子节点。
- 每个节点至多有`2t-1`个关键字，每个节点至多有`2t`个子节点。

##### 匹配规则

- 全值匹配
- 匹配最左前缀
- 匹配列前缀
- 匹配范围值
- 精确匹配某一列范围匹配另外一列
- 只访问索引的查询

#### HASH

##### 特性

- 只包含哈希值和行指针，不储存字段值
- 不是按照索引值顺序储存，无法用于排序
- 不支持部分索引匹配查找
- 只支持等级比较查询
- 访问哈希索引非常快，除非有哈希冲突。发生冲突时需遍历链表中所有行指针，逐行进行比较，直到找出符合条件的行。
- 冲突极多的话，索引维护操作代价很高。在选择性很低的列上建立哈希索引，当删除一行时，就需要遍历对应哈希值链表上的每一行。

##### Tips

- url地址查询，可以在表中添加url对应的hash数值列，这样在查询时会极大增强性能。hash的计算可以使用触发器在数据插入时计算。

#### R-Tree

### 策略

- 在查询语句中，索引不能是表达式的一部分，也不能是函数的参数。

- 前缀索引的长度应使选择性接近完整列的选择性。

- 多列索引要从所选列的选择性和基数、`WHERE`子句中的排序、分组、范围条件等因素分析。

- 聚簇索引，一种数据储存方式，在叶节点中保存整个行数据。在MySQL中只有InnoDB使用这种方式，主键索引包含行数据。二级索引的叶节点保存的是主键值。聚簇索引保存整个表的数据，就是一个表。

  优点

  - 相关数据保存在一起，在依据索引查询数据，不必再次查询其它信息，减少IO
  - 索引和数据保存在同一个B-Tree中，数据访问更快
  - 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

  缺点

  - 如果数据都放在内存中，访问的顺序就没那么重要，聚簇索引就没有什么优势
  - 插入速度严重依赖插入顺序
  - 更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置
  - 插入新行和主键更新导致需要移动行时，可能面临页分裂问题，这会导致表占用更多的磁盘空间。
  - 可能导致全表扫描变慢，尤其行比较稀疏，或者也分裂导致数据存储不连续的时候
  - 二级索引可能过大
  - 二级索引访问需要两次索引查找，而不是一次

- 覆盖索引，一个索引包含了所有需要查询的字段的值，称之为覆盖索引。

  - 索引条目通常远小于数据行的大小，所有只需要只读取索引，那MySQL就会极大地减少数据访问量
  - 因为索引是按照列值顺序储存的，所以对应I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。
  - 对于只缓存索引的储存引擎如MyISAM，每次查询要访问数据都需要一此系统调用，导致性能问题。
  - 对于InnoDB而言，覆盖索引可以避免了二级索引对主键索引的二次查询

- 排序，通过排序操作或者按索引顺序扫描

- 压缩索引，MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中。

- 冗余索引，可以提升相关列的查询性能，但会加大索引成本，更新性能下降。

- 将经常使用的列放在索引前缀，如果查询未用到该列可以使用`IN`子句让MySQL选择该索引。应当将范围条件列放在索引末位，尽量避免MySQL无法使用索引。

- 可以使用反范式、预先计算、缓存、延迟关联可以高效排序。
