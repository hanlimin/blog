### Java5

#### CopyOnWriteArrayList

CopyOnWriteArrayList是ArrayList的线程安全版本， 写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略。写时线程安全是通过ReentrantLock锁实现的。

- 是线程安全的
- 写操作会复制整个基础数组，因此写操作开销很大
- 适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形。

#### ConcurrentLinkedQueue

ConcurrentLinkedQueue是一个依据Maged M. Michael and Michael L. Scot的无阻塞算法，基于链表的无界线程安全无阻塞队列。高性能、无锁。

offer()的代码如下：

```java
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);
        //自旋，t是tail节点的引用，p为t
    for (Node<E> t = tail, p = t;;) {
        //q为tail的后继
        Node<E> q = p.next;
        if (q == null) {
            // 此时tail后没有其它线程添加的新节点
            if (p.casNext(null, newNode)) {
            		//每新增两个节点才会更新尾节点指针
                if (p != t)
                    casTail(t, newNode); 
                return true;
            }
        }
        else if (p == q)
            // 并发环境导致p指向的使哨兵节点。修改p的指向的节点，如果tail修改了，就将p置为tail，否则将p置为head
            p = (t != (t = tail)) ? t : head;
        else
            /**
             * 如果q不等于null，且p不等于q，这时可能有其他的线程恰好抢先一步添加了一个节点
             * 则判断p与t是否不同，即tail是否改变：
             * 1. p与t相同，表示这是第一循环且t未改变，此时将q赋值给p，即后移；
             * 2. p与t不同，但t未发生改变，说明p已经后移了，此时将q赋值给p，即继续后移；
             * 3. p与t不同，且t发生了改变，即tail更新了，此时将p指向t（即新的tail，指向尾部是最优方式）
             */
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```

`offer()`方法逻辑大致分为三步：

1. 找到真正的尾节点p。
2. CAS更新`p.next`。
3. 判断是否CAS更新tail位置。

poll()的代码如下：

```java
public E poll() {
    restartFromHead:
    for (;;) {
        for (Node<E> h = head, p = h, q;;) {
            E item = p.item;
				  // 判断p的item是否为null，如果不是就CAS方式设置为null
            if (item != null && p.casItem(item, null)) {
                if (p != h) 
                    //空节点数量达到两个，移动head
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            // 都是无效节点
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            // 并发环境，已调用updateHead方法，使p转变为哨兵节点
            else if (p == q)
                continue restartFromHead;
            else
                // 当前p节点为无效节点，移动p
                p = q;
        }
    }
}
```

`pool()`方法逻辑过程：

1. 找到有效头节点p。
2. 判断节点p内容`item`是否为`NULL`，如果为`NULL`表示该节点已经出队了，如果`item`不为`NULL`则使用CAS替换为`NULL`
3. 如果成功判断是否需要更新头结点指针
4. 判断是否CAS更新head位置

通过CAS保证头节点、尾节点变动原子性操作，就能实现队列入队出队线程安全。

#### BlockingQueue

阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 

阻塞队列提供了四种处理方法:

| 方法\处理方式 | 抛出异常  | 返回特殊值 | 一直阻塞 | 超时退出           |
| :------------ | :-------- | :--------- | :------- | :----------------- |
| 插入方法      | add(e)    | offer(e)   | put(e)   | offer(e,time,unit) |
| 移除方法      | remove()  | poll()     | take()   | poll(time,unit)    |
| 检查方法      | element() | peek()     | 不可用   | 不可用             |

#### LinkedBlockingQueue

基于链表实现的有界阻塞队列。使用ReentranLocK保证线程安全，使用ReentranLocK的Condition实现等待通知。内部使用两个锁分别对应入队和出队操作。

#### ArrayBlockingQueue

基于数组实现的有界阻塞队列。使用ReentrantLock锁实现阻塞

#### SynchronousQueue

 不存储元素阻塞队列，实现进行线程之间的元素传送。通过LockSupport实现阻塞等待，通过CAS实现更新操作原子性。 由于对于传递性场景进行了某种充分的优化，其中最重要的是不需要锁，因此在只需要同步，不需要大量存储元素的场景下吞吐量很高。 

#### DelayQueue 

使用`PriorityQueue`实现的无界延时队列。队列中元素必须实现`Delayed`接口。指定元素的延时时间， 如果元素没有达到延时时间，就阻塞当前线程。使用ReentrantLock锁实现阻塞。

#### PriorityBlockingQueue 

基于最小堆实现的无界阻塞优先队列。使用ReentrantLock锁实现同步， 使用CAS实现动态扩容 

#### CopyOnWriteArraySet 

使用CopyOnWriteArrayList实现的无界集合。

#### ConcurrentHashMap

1.6

在HashTable的基础上，使用分段锁机制，减小锁的颗粒，允许多个线程同时访问，冲突使用链表解决。ConcurrentHashMap由Segment划分成多个数据段。内部类Segment继承自ReentrantLock，内部储存着HashEntry数组，部分操作使用ReentrantLock的锁达成同步。同段多线程ReentrantLock获取锁可能导致线程等待。

segmentShift和segmentMask这两个全局变量的主要作用是根据key的hash值得高位确定segment索引。

key、value不能为null。

1.7 

在1.6基础上，添加尝试自旋获取锁，如果重试次数达到了`MAX_SCAN_RETRIES` 则改为阻塞锁获取，保证能获取成功 。

1.8

放弃了分段锁， 采用了 `CAS + synchronized` 来保证并发安全性 。 同时为了防止哈希冲突严重时退化成链表（冲突时会在该位置生成一个链表，哈希值相同的对象就链在一起），会在链表长度达到阈值（8）后转换成红黑树（比起链表，树的查询效率更稳定）。 

size是一个瞬间的状态，所以它将每次修改的计数放在了ConcurrentHashMap的局部变量中，调用size的时候，直接去获取这个计数，比1.7方便许多。 

### Java6

#### LinkedBlockingDeque 

基于链表的无界双端阻塞队列。使用ReentrantLock锁实现阻塞。

#### ConcurrentSkipListMap

使用跳跃列表的数据结构进行快速查找。

#### ConcurrentSkipListSet 

使用ConcurrentSkipListMap实现的集合。

### Java7

#### LinkedTransferQueue 

> http://ifeve.com/java-transfer-queue/ 

1.7版本添加。LinkedBlockingQueue是基于链表的无界线程安全阻塞队列，实现了`LinkedTransferQueue`接口，通过LockSupport实现阻塞等待，通过CAS实现更新操作原子性。  

TransferQueue接口，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费。新添加的transfer方法用来实现这种约束。顾名思义，阻塞就是发生在元素从一个线程transfer到另一个线程的过程中，它有效地实现了元素在线程之间的传递。

 [Doug Lea说](http://cs.oswego.edu/pipermail/concurrency-interest/2009-February/005888.html)从功能角度来讲，LinkedTransferQueue实际上是ConcurrentLinkedQueue、SynchronousQueue（公平模式）和LinkedBlockingQueue的超集。而且LinkedTransferQueue更好用，因为它不仅仅综合了这几个类的功能，同时也提供了更高效的实现。 

#### ConcurrentLinkedDeque 

基于链表的无界双端队列，使用CAS保证并发安全。

>
>
>[1] Maged M. Michael & Michael L. Scot. Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms, 1996)