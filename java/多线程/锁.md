### synchronized

- 修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁。
- 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。
- 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。

synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。 

### Lock的实现

#### ReentrantLock 

基于内部实现主要通过AQS实现，内部类Sync继承AQS实现的同步机制，又分别实现了NonfairSync和FairSync两个子类，分别对应非公平锁和公平锁的实现。

##### 特性

- 重入性
- 支持非公平和公平两种模式
- 支持Condition

##### 公平锁的 lock 方法

```java
protected final boolean tryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // 1. 和非公平锁相比，这里多了一个判断：是否有线程在等待
        if (!hasQueuedPredecessors() &&
            compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0)
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

 在注释1的位置，有个`!hasQueuedPredecessors()`条件，意思是说当前同步队列没有前驱节点（也就是没有线程在等待）时才会去`compareAndSetState(0, acquires)`使用CAS修改同步状态变量。所以就实现了公平锁，根据线程发出请求的顺序获取锁。 

##### 非公平锁的lock方法

```java
final void lock() {
    // 2. 和公平锁相比，这里会直接先进行一次CAS，成功就返回了
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
}
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        //3.这里也是直接CAS，没有判断前面是否还有节点。
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    return false;
}
```

 非公平锁的实现在刚进入lock方法时会直接使用一次CAS去尝试获取锁，不成功才会到acquire方法中，如注释2。而在nonfairTryAcquire方法中并没有判断是否有前驱节点在等待，直接CAS尝试获取锁，如注释3。由此实现了非公平锁。 

#### ReentrantReadWriteLock

基于AQS实现的同步机制，有子类分别对应公平和非公平两种版本。

##### 特性

- 重入性 
- 支持非公平和公平两种模式
- 支持共享锁和独占锁
- 互斥锁支持Condition

#### CountDownLatch

CountDownLatch是一个同步辅助类，通过AQS实现的一个闭锁。在其他线程完成它们的操作之前，允许一个多个线程等待。简单来说，CountDownLatch中有一个锁计数，在计数到达0之前，线程会一直等待。

```java
// 阻塞
await();
// 减少计数
countDown();
```



#### CyclicBarrier

CyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。

```java
// 阻塞
await();
// 重置计数
reset();
```



#### Phaser

Phaser是java7中引入的，属于线程同步辅助工具类。 在功能上跟CyclicBarrier和CountDownLatch差不多，但支持更丰富的用法。

```java
// 类似于CyclicBarrier的await()方法，等待其它线程都到来之后同步继续执行。
arriveAndAwaitAdvance();
// 把执行到此的线程从Phaser中注销掉。
arriveAndDeregister();
// 判断Phaser是否终止。
isTerminated();
// 将一个新的参与者注册到Phaser中，这个新的参与者将被当成没有执行完本阶段的线程。
register()：
// 强制Phaser进入终止态
forceTermination();
```

#### Semaphore

Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 
