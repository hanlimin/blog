### CopyOnWriteArrayList

 CopyOnWriteArrayList是ArrayList的线程安全版本， 写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略，Java并发包中类似的容器还有CopyOnWriteSet。写时线程安全是通过ReentranLock锁实现的。

- 是线程安全的
- 写操作会复制整个基础数组，因此写操作开销很大
- 适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形。

### ConcurrentLinkedQueue

 ConcurrentLinkedQueue是一个基于链接节点的无界线程安全的队列，按照先进先出原则对元素进行排序。新元素从队列尾部插入，而获取队列元素，则需要从队列头部获取。

Node节点代码：

```java
private static class Node<E> {
    volatile E item;
    volatile Node<E> next;
    
    Node(E item) {
            UNSAFE.putObject(this, itemOffset, item);
        }
	  //更改Node中的数据域item
    boolean casItem(E cmp, E val) {
        return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);
    }
    //惰性更改Node中的指针域next
    void lazySetNext(Node<E> val) {
        UNSAFE.putOrderedObject(this, nextOffset, val);
    }
    //更改Node中的指针域next
    boolean casNext(Node<E> cmp, Node<E> val) {
        return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);
    }
		.......
}
```

 Node节点主要包含了两个属性：一个是item，另一个是next指针，用于指向下一个节点从而构成链式队列。并且都是用volatile进行修饰的，以保证内存可见性。以及三个使用CAS的方法。

 ConcurrentLinkedQueue含有这样两个成员变量：

```java
private transient volatile Node<E> head;
private transient volatile Node<E> tail;
```

ConcurrentLinkedQueue通过持有头尾指针进行管理队列 。



ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：

1. 使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。
2. head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。
3. 由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式来维护非阻塞算法的正确性。
4. 以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。
5. 为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。



#### 不变式

在后面的源代码分析中，我们将会看到队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式 ( 基本不变式，head 的不变式和 tail 的不变式 )，来约束队列中方法的执行。通过这三个不变式来维护非阻塞算法的正确性。

不变式：并发对象需要一直保持的特性。不变式是并发对象的各个方法之间必须遵守的“契约”，每个方法在调用前和调用后都必须保持不变式。采用不变式，就可以隔离的分析每个方法，而不用考虑它们之间所有可能的交互。

##### 基本不变式

在执行方法之前和之后，队列必须要保持的不变式：

- 当入队插入新节点之后，队列中有一个 next 域为 null 的（最后）节点。
- 从 head 开始遍历队列，可以访问所有 item 域不为 null 的节点。

##### head 的不变式和可变式

在执行方法之前和之后，head 必须保持的不变式：

- 所有“活着”的节点（指未删除节点），都能从 head 通过调用 succ() 方法遍历可达。
- head 不能为 null。
- head 节点的 next 域不能引用到自身。

在执行方法之前和之后，head 的可变式：

- head 节点的 item 域可能为 null，也可能不为 null。
- 允许 tail 滞后（lag behind）于 head，也就是说：从 head 开始遍历队列，不一定能到达 tail。

##### tail 的不变式和可变式

在执行方法之前和之后，tail 必须保持的不变式：

- 通过 tail 调用 succ() 方法，最后节点总是可达的。
- tail 不能为 null。

在执行方法之前和之后，tail 的可变式：

- tail 节点的 item 域可能为 null，也可能不为 null。
- 允许 tail 滞后于 head，也就是说：从 head 开始遍历队列，不一定能到达 tail。
- tail 节点的 next 域可以引用到自身。

在接下来的源代码分析中，在初始化 ConcurrentLinkedQueue 之后及调用入队 / 出队方法之前和之后，我们都会参照上面三个不变式来分析它们的正确性



ConcurrentLinkedQueue，CLQ代码中分析整理得到以下规则：

1. 有且仅有一个Node的next为null
2. Node的值为null代表此节点无效，包括哨兵节点（sentinel）
3. Node的next指向自己表示此节点无效

规则1很好理解，M&S算法也是这样的。一般就是尾部节点，M&S算法中有可能因为竞争失败导致取到的tail指向next不为null的节点，但是顺着一定可以找到一个next为null的节点。

规则2也不是很难理解，CLQ对节点的值进行CAS设置为null来保证不会有两个线程取同一个节点的值，本质上和M&S用CAS推进head节点一致。但是这么做导致

1. 值不能为null
2. head在实际queue的首节点之前，没有推进



### BlockingQueue

这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。

### ConcurrentHashMap

线程安全的HashMap

### ConcurrentSkipListMap

跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。



>
>
>[1] Maged M. Michael & Michael L. Scot. Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms, 1996)