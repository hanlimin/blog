### List

#### CopyOnWriteArrayList

CopyOnWriteArrayList是ArrayList的线程安全版本， 写操作则通过创建底层数组的新副本来实现，是一种读写分离的并发策略。写时线程安全是通过ReentranLock锁实现的。

- 是线程安全的
- 写操作会复制整个基础数组，因此写操作开销很大
- 适用于如下情况：数组大小较小，并且读操作比写操作多很多的情形。

### Queue

#### ConcurrentLinkedQueue

ConcurrentLinkedQueue是一个依据Maged M. Michael and Michael L. Scot的无阻塞算法，基于链表的无界线程安全无阻塞队列。高性能、无锁。

offer()的代码如下：

```java
public boolean offer(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);
        //自旋，t是tail节点的引用，p为t
    for (Node<E> t = tail, p = t;;) {
        //q为tail的后继
        Node<E> q = p.next;
        if (q == null) {
            // 此时tail后没有其它线程添加的新节点
            if (p.casNext(null, newNode)) {
            		//每新增两个节点才会更新尾节点指针
                if (p != t)
                    casTail(t, newNode); 
                return true;
            }
        }
        else if (p == q)
            // 并发环境导致p指向的使哨兵节点。修改p的指向的节点，如果tail修改了，就将p置为tail，否则将p置为head
            p = (t != (t = tail)) ? t : head;
        else
            /**
             * 如果q不等于null，且p不等于q，这时可能有其他的线程恰好抢先一步添加了一个节点
             * 则判断p与t是否不同，即tail是否改变：
             * 1. p与t相同，表示这是第一循环且t未改变，此时将q赋值给p，即后移；
             * 2. p与t不同，但t未发生改变，说明p已经后移了，此时将q赋值给p，即继续后移；
             * 3. p与t不同，且t发生了改变，即tail更新了，此时将p指向t（即新的tail，指向尾部是最优方式）
             */
            p = (p != t && t != (t = tail)) ? t : q;
    }
}
```

`offer()`方法逻辑大致分为三步：

1. 找到真正的尾节点p。
2. CAS更新`p.next`。
3. 判断是否CAS更新tail位置。

poll()的代码如下：

```java
public E poll() {
    restartFromHead:
    for (;;) {
        for (Node<E> h = head, p = h, q;;) {
            E item = p.item;
				  // 判断p的item是否为null，如果不是就CAS方式设置为null
            if (item != null && p.casItem(item, null)) {
                if (p != h) 
                    //空节点数量达到两个，移动head
                    updateHead(h, ((q = p.next) != null) ? q : p);
                return item;
            }
            // 都是无效节点
            else if ((q = p.next) == null) {
                updateHead(h, p);
                return null;
            }
            // 并发环境，已调用updateHead方法，使p转变为哨兵节点
            else if (p == q)
                continue restartFromHead;
            else
                // 当前p节点为无效节点，移动p
                p = q;
        }
    }
}
```

`pool()`方法逻辑过程：

1. 找到有效头节点p。
2. 判断节点p内容`item`是否为`NULL`，如果为`NULL`表示该节点已经出队了，如果`item`不为`NULL`则使用CAS替换为`NULL`
3. 如果成功判断是否需要更新头结点指针
4. 判断是否CAS更新head位置

通过CAS保证头节点、尾节点变动原子性操作，就能实现队列入队出队线程安全。

#### LinkedBlockingQueue 

LinkedBlockingQueue是基于链表的有界线程安全阻塞队列，实现了BlockingQueue接口，使用ReentranLocK保证线程安全，使用ReentranLocK的Condition实现等待通知。内部使用两个锁分别对应入队和出队操作。

锁的时候锁整个队列 。

#### DelayQueue 



#### LinkedTransferQueue 

1.7版本添加。LinkedBlockingQueue是基于链表的无界线程安全阻塞队列，实现了`LinkedTransferQueue`接口，通过LockSupport实现阻塞等待，通过CAS实现更新操作原子性。  兼顾性能、锁。

1. `transfer(E e)`：若当前存在一个正在等待获取的消费者线程，即立刻移交之；否则，会插入当前元素e到队列尾部，并且等待进入阻塞状态，到有消费者线程取走该元素。
2. `tryTransfer(E e)`：若当前存在一个正在等待获取的消费者线程（使用take()或者poll()函数），使用该方法会即刻转移/传输对象元素e；若不存在，则返回false，并且不进入队列。这是一个不阻塞的操作。
3. `tryTransfer(E e, long timeout, TimeUnit unit)`：若当前存在一个正在等待获取的消费者线程，会立即传输给它;否则将插入元素e到队列尾部，并且等待被消费者线程获取消费掉；若在指定的时间内元素e无法被消费者线程获取，则返回false，同时该元素被移除。
4. `hasWaitingConsumer()`：判断是否存在消费者线程。
5. `getWaitingConsumerCount()`：获取所有等待获取元素的消费线程数量

#### 



#### PriorityBlockingQueue 

#### ArrayBlockingQueue

#### BlockingQueue

这是一个接口，JDK内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。

### Dequeue

#### ConcurrentLinkedDeque 

#### LinkedBlockingDeque 

### Map

#### ConcurrentHashMap

线程安全的HashMap

#### ConcurrentSkipListMap

跳表的实现。这是一个Map，使用跳表的数据结构进行快速查找。

### Set

#### CopyOnWriteArraySet 

在内部关联一个CopyOnWriteArrayList属性，Set的接口实现都是调用CopyOnWriteArrayList的方法实现的。

#### ConcurrentSkipListSet 

在内部关联一个ConcurrentSkipListMap属性，Set的接口实现都是调用ConcurrentSkipListMap的方法实现的。



>
>
>[1] Maged M. Michael & Michael L. Scot. Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms, 1996)