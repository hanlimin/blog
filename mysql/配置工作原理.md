## 基础配置

- `myisam_block_size`和`innodb_page_size`

  块大小也很重要，因为它影响了MyISAM、操作系统缓存、以及文件系统之间的交换。如果MySQL块大小跟操作系统的不匹配，会导致写时读取的情况。在MySQL 5.0以及更早版本没有办法配置索引块大小。在MySQL 5.1以及更新版本中，可以配置MyISAM的索引块大小，配置项为`myisam_block_size`。也可以在CREATE TABLE或者CREATE INDEX 语句中使用KEY_BLOCK_SIZE选项。InnoDB配置项为`innodb_page_size`。

- `tmp_table_size`和`max_heap_table_size`

  这两个配置控制使用Memory引擎的内存临时表能使用多大的内存。如果隐式内存临时表的大小超过这两个设置的值，将会被转化为磁盘MyISAM表，所以它的大小可以持续增长，这个转化过程可以通过`SHOW PROCESSLIST`中看到。应该简单地把这两个变量设为同样的值。可以通过`SHOW STATUS`计数器查看某段时间内的变化，以此来查看创建临时表的频率以及是否是磁盘临时表。

- `max_connections`

  这个设置的作用就像一个紧急刹车，以保证服务器不会因应用程序激增的连接而不堪重负。可以通过`Max_used_connections`状态变量，来观察服务器连接活动状态。

- `expire_logs_days`

  如果启用了二进制日志，应该打开这个选项，可以让服务器在指定的天数之后清理旧的二进制文件。

- `max_allowed_packet`

  这个配置防止服务器发送太大包，也会控制多大包可以被接受。

- `max_connect_errors`

  在短暂的时间内不断尝试连接，客户端可能被列入黑名单。

- `skip_name_resolve`

  这个选项禁用了DNS查找

- `sql_mode`

  配置MySQL的SQL方言。

- `sysdata_is_now`

  配置控制行为

- `innodb`

  若配置为FORCE，只有在InnoDB可以启动是，服务器才会启动。

- `innodb_antoinc_lock_mode`

  这个选项可以控制InnoDB如何生成自增主键值。

- `innodb_buffer_pool_instances`

  可以把缓冲池切分为多个段，这可能是在高负载的多核机器上提升MySQL可扩展性最重要的方式了。多个缓冲池分散了工作压力，所以一些全局Mutex竞争没那么大了。

- `innodb_io_capacity`

  设置来告知InnoDB服务器有多大的I/O能力

- `innodb_read_io_threads`和`innodb_wiret_io_threads`

  这些选项控制有多少后台线程可以被I/O操作使用。

- `innodb_strict_mode`

  这个配置让MySQL在某些条件下把警告改成抛错。

- `innodb_old_blocks_time`

  InnoDB有两个段缓冲池LRU链表，设计目的是防止换出长期使用很多次的页面。这个变量指定一个页面从LRU链表的年轻部分转移到年老部分之前必须经过的毫秒数。

## InnoDB

InnoDB储存引擎的内存和硬盘结构图。

<img src="../imgs/innodb-architecture.png" />

### 缓存配置

- InnoDB 缓冲池
- InnoDB日志文件和MyISAM数据的操作系统缓存
- MyISAM键缓存
- 查询缓存
- 无法手工配置的缓存，例如二进制日志和表定义文件的操作系统缓存

#### InnoDB缓冲池（Buffer Pool）

内容包括：索引、行的数据、自适应哈希索引、插入缓冲、锁以及其它内部数据。使用缓冲可以延迟写入，这样就可以合并多个写入操作，然后一起顺序的写回。大的缓冲池会导致预热和关闭都会话费很长时间。如果事先知道什么时候关闭InnoDB，可以在运行时修改`innodb_max_dirty_pages_pct`变量，将值变小，等待刷新线程清理缓冲池，然后在脏页数量较少时关闭。在启动时，预热缓冲池也可能会花费很长时间，可以通过立刻进行全表扫描或者索引扫描等方法直接加快预热过程。可以使用`init_file`设置来达到加快的目的。

- `innodb_max_dirty_pages_pct` InnoDB中缓冲池脏页占比。
- `innodb_buffer_pool_size` InnoDB缓冲池大小

#### 线程缓存

线程缓存保存那些当前没有与连接关联但是准备为后面新的连接服务的线程。配置项`thread_cache_size`制定了MySQL可以保持在缓存中的线程数。可以观察`Threads_connnected`状态变量来配置相应的数值。

- `thread_cache_size` 可缓存线程数

#### 表缓存（Table Cache）

保存着表的`.frm`文件的解析结果和一些其它数据。表缓存分离成两部分：一个是打开表的缓存，一个是表定义缓存。可通过`table_open_cache`和`table_definition_cache`变量来配置。打开的表依然是每个 线程、每个表用的，但是表定义是全局的，可以被所有连接有效的共享。

-  `open_files_limit ` MySQL实例进程能打开的文件描述符最大值。
-  `table_cache_size` 表定义缓存大小。
- `table_open_cache` 内存中允许打开表的数量。对性能影响较大。
- `table_definition_cache` 内存中可打开的表结构数量。

#### InnoDB数据字典（Date Dictionary）

InnoDB自己的表缓存。当InnoDB打开一张表，就增加了一个对应的对象到数据字典。每张表可能占用4KB或者更多的内存，当表关闭时也不会从数据字典中移除它们。因此，随着时间推移，导致数据字典中的元素不断地增长。相比MyISAM，InnoDB没有将统计信息持久化，而是每次打开表时重新计算，这需要很多I/O操作，所以代价很高。在打开之后，每隔一段时间或者遇到触发事件，也会重新计算统计信息。可以开启` innodb_stats_persistent`选项来持久化统计信息以解决这个问题。即使开启之后，InnoDB统计操作还可能对服务器和一些特定的查询产生冲击，可以关闭`innodb_stats_on_metadata`选项来避免耗时的表统计信息刷新。

- ` innodb_stats_persistent` 持久化统计信息到磁盘。
- `innodb_stats_on_metadata` 表统计信息刷新开关。

### I/O配置

有一些配置影响着MySQL怎样同步数据到磁盘以及如何做恢复操作。这些操作对性能的影响非常大，因为都涉及到昂贵的I/O操作。它们也表现了性能和数据安全之间的权衡。InnoDB不仅允许控制怎么恢复，还允许控制怎么打开和刷新数据，这会对恢复和整体性能产生巨大的影响。

#### InnoDB刷新方法

使用`innodb_flush_method`选项可以配置InnoDB如何跟系统文件系统相互作用。Windows和非Windows的操作系统对这个选项的值是互斥的。

#### InnoDB事务日志

InnoDB使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无需在每个事务提交时把缓冲池的脏块刷新到磁盘中。事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机I/O。InnoDB使用日志把随机I/O变成顺序I/O。一旦日志安全写到磁盘，事务就持久化了，即使变更还没写到数据文件。InnoDB的日志时环形方式写的：当写到文件的尾部，会重新跳转到开头继续写，但不会覆盖到还未应用到数据文件的日志记录。

InnoDB使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。整体日志文件大小受控于`innodb_log_file_size`和`innodb_log_files_in_group`两个参数，这对写性能非常重要。InnoDB使用多个文件作为一组循环日志。通常不需要修改默认日志数量，只修改每个日志文件的大小即可。如果有大事务，可以增加日志缓冲区大小可以帮助减少I/O。变量`innodb_log_buffer_size`可以控制日志缓冲区的大小。

可以通过`SHOW INNODB STATUS`的输出中LOG部分来监控InnoDB的日志和日志缓冲区的I/O性能，通过观察`Innodb_os_log_write`状态变量来查看InnoDB对日志文件写出了多少数据。

作为经验法则，日志文件的全部大小，应该足够容纳服务器一个小时的活动内容。

- `innodb_log_file_size`：每个日志文件大小
- `innodb_log_files_in_group`：在每组日志文件中的日志文件数量。
- `innodb_log_buffer_size` 日志缓冲大小。
- `innodb_flush_log_at_trx_commit`：日志缓冲的刷新频繁程度。

#### InnoDB表空间

InnoDB把数据保存在表空间内，本质上是有一个或多个磁盘文件组成的虚拟文件系统。InnoDB使用表空间实现很多功能，并不只是储存表和索引，它保存了回滚日志、插入缓冲、双写缓冲以及其它内部数据结构。通过`innodb_date_file_path`配置项可以定制表空间文件。这些文件放在`innodb_data_home_dir`指定的目录下。开启`innodb_file_per_table`选项可以是每个表对应一个表空间。即使打开了`innodb_file_per_table`选项，依然需要为回滚日志和其他系统数据创建共享表空间。

- `innodb_date_file_path`： 定义了InnoDB表空间数据文件的名字、大小等属性。`autoextend`允许表空间在超过了分配的空间是还能增长，可以配置最后一个文件自动扩展。可以再使用`max`配置自动扩展文件大小上限。
- `innodb_data_home_dir`：指定了InnoDB表空间数据文件所在目录。
- `innodb_file_per_table`：一个开关选项，是否让InnoDB为每张表使用一个文件。即一个表对应一个表空间。

##### 旧版本行

在写压力大的环境下，InnoDB的表空间可能增长得非常大。如果事务保持打开状态很久，并且使用默认的REPEATABLE READ事务隔离级别，InnoDB将不能删除旧的行版本。InnoDB把旧版本存在共享表空间，所以如果有更多的数据在更新，共享表空间会持续增长。没有清理的行版本会对所有的查询产生影响，因为它们事实上使得表和索引更大了。

MySQL使用一个线程来清理事务，如果工作负载过高可能导致清理线程处理速度跟不上旧版本行数增加的速度。可以使用`SHOW ENGINE INNODB STATUS`命令可以观察历史链表的长度来定位问题。可以配置`innodb_max_purge_lag`强制MySQL减速来使InnoDB的清理线程可以跟得上。

- `innodb_max_purge_lag`：定义了清理线程可以等待被清理的最大事务数量。

##### 双写缓冲

InnoDB使用双写缓冲来避免页没写完整所导致的数据损坏。当InnoDB从缓冲池刷新页面到磁盘时，首先把它们写到双写缓冲，然后再把它们写到其所属的数据区域中。如果有一个不完整的页写到了双写缓冲，原始的页依然会在磁盘上它的真实位置。当InnoDB恢复时，它将用原始页面替换掉双写缓冲中的损失页面。然而，如果双写缓冲成功写入，而写到页真实位置失败了，InnoDB在恢复时将使用双写缓冲中的拷贝来替换。有些场景下，双写缓冲确实没有必要。可以通过设置`innodb_doublewrite`为0来关闭双写缓冲。

- `innodb_doublewrite`：一个开关选项，是否开启双写缓冲。

#### 二进制日志刷新策略

`sync_binlog`选项控制MySQL怎么刷新二进制日志到磁盘。默认值为0，意味着MySQL并不刷新，由操作系统自己决定什么时候刷新缓存到持久化设备。如果这个值比0大，它指定了两次刷新到磁盘的动作之间隔多少次二进制日志写操作。值为1时，每提交提交一次事务刷新一次。其它值n很罕见，当提交的日志组=n时刷新一此。

### 并发配置

在高并发场景下，InnoDB的某些方面的性能可能会降低，唯一的办法是限制并发。

最基本的限制并发的方式是使用`innodb_thread_concurrency`变量，它会限制一次性可以有多少线程进入内核，0表示不限制。如果已经进入内核的线程超过了允许的数量，新的线程就无法进入内核。

InnoDB使用两段处理来尝试让线程尽可能地高效地进入内核。两段策略减少了因操作系统调度引起的上下文切换。线程第一次休眠`innodb_thread_sleep_delay`微妙，然后重试。如果它依然不能进入内核，则放入一个等待线程队列，让操作系统来处理。

一旦线程进入内核，它会有一定数量的票据，可以让它免费返回内核，不需再做并发检查。`innodb_concurrency_tickets`选项控制票据数量。票据是按查询授权的，而不是按事务。一旦查询完成，它没用完的票据就销毁了。

`innodb_commit_concurrency`变量控制有多少个线程可以同一时间提交。

## MyISAM

### 缓冲配置

#### MyISAM键缓存（Key Caches）

MyISAM自身只缓存索引，不缓存数据。可以使用`CACHE INDEX`命令来将表映射到对应的缓冲区。可以使用`LOAD INDEX`命令预缓存指定表的索引。MyISAM使用操作系统缓存来缓存数据文件，通常数据文件较索引要大，所以把更多的内存保留给操作系统缓存而不是键缓存是有意义的。最后，即使没有任何MyISAM表，依然需要将key_buffer_size设置为较小的值，因为MySQL服务器有时会在内部使用MyISAM表，例如GROUP BY语句可能会使用MyISAM做临时表。

- `key_buffer_size`，设置大小不超过索引总大小或操作系统缓存保留内存的25%~50%，以更小的为准。可以创建多个命名的键缓冲。

### I/O配置

#### 键缓冲刷新

MyISAM通常每次写操作之后就把索引变更刷新到磁盘。如果在一张表上做很多修改，批量操作会更快一点。一种办法时`LOCK TABLES`延迟写入，直到解锁这些表。通过配置`delay_key_wirte`变量，也可以延迟索引写入，修改的键缓冲块直到表被关闭才会刷新。

- `OFF` 每次写操作刷新键缓冲。
- `ON` 打开延迟键写入，但是只对用`DELAY_KEY_WRITE`选项创建的表有效。
- `ALL` 所有的MyISAM表都会使用延迟键写入。

#### 表损坏恢复

`myisam_recover`选项控制MyISAM怎么寻找和修复错误。

- `DEFAULT` 默认值，在恢复时不执行其它动作
- `BACKUP` 让MySQL将数据文件的备份写道`.BAK`文件，以便随后进行检查。
- `FORCE` 即使`.MYD`文件中丢失的数据可能超出一行，也让恢复继续。
- `QUICK` 除非有删除块，否则跳过恢复。

### 并发配置

MyISAM删除操作不用重新整理整个表，只是把行标记为删除，在表中留下空洞。MyISAM倾向于在可能的时候填满这些空洞，在插入时重新利用这些空洞，如果没有空洞了才会把新行插入表的末尾。尽管MyISAM是表级锁，它依然可以一边读取，一边并发追加新行。然而，若表中间的某些数据变动了话，还是很难提供一致读。所以除非插入操作在表的末尾，否则不支持并发插入。可以通过设置`concurrent_insert`这个变量来控制MyISAM的并发插入

- 0 不允许并发插入，所有插入都会对表加互斥锁。
- 1 默认值。只要表中没有空洞，就允许并发插入。
- 2 MySQL 5.0以及更新版本中有效。它强制并发插入到表的末尾，即使表中有空洞。如果没有线程从表中读取数据，MySQL将把新行放在空洞中。

​	

