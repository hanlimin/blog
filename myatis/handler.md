### ParameterHandler
一个接口只有两个方法，一个getParameterObject获取参数对象？setParameters方法入参是PreparedStatement作用是为入参PreparedStatement配置参数。
###  DefaultParameterHandler
实现了ParameterHandler接口，封装了TypeHandlerResgistry、MappedStatement、一个Obejct paraameterObejct、BoundSql、Configuration。构造参数只有MappedStatement、parameterObject、BoundSql。多个的属性是从MappedStatement中获取的。

### ResultHandle<T>
一个接口，只有一个方法handlerResult入参为ResultContext

### DefaultResultHandler
实现了ResultHandler接口，泛型类型就是Object，内部是个List列表，handlerResult则会从ResultContext中获取resultObject添加到这个列表中。

### DefaultMapResultHandler
实现了ResultHandler接口，除了原接口一个又添加添加了一个一个泛型，新添加的泛型K作为key的类型，原接口泛型V作为value类型的Map属性mappedResults。此外特殊的是还有来自构造方法的字符串属性mapKey。在handleResult方法中，首先调用ResultContext的getResultObject方法获取V类型的value，将value对象构建出MetaObject，再从这个MetaObject对象中获取mapKey对应的值key并强转成K类型，最后将key和vlaue添加到mappedResults中。

### ResultSetHandler
一个接口只有三个方法，分别处理普通Statemnet、返回Curor的查询、callable查询的结果集处理。

### DefaultResultResultSetHandler
封装了很多属性
-   getFirstResultSet
    私有方法，入参为Statement，通过Statement的getMoreResults和getUpdateCount获取第一个不为null的ResultSet，如果最后未获取到则返回null，有值则构建ResultSetWrapper封装ResultSet并返回。
-   handleResultSets
    创建一个整数计数resultSetCount初始值为0。
    首先调用getFirstResultSet获取到一个ResultSetWrapper。
    获取mappedStatement的ResultMap列表记为resultMaps。
    将resultMaps的size记为resultMapCount。
    调用validateResultMapsCount验证ResultSetWapper不为null的情况下MappedStatement中的ResultMapp不为空。
    如果rsw不为null且resultMapCount大于resultSetCount则进入循环。在循环体内，获取resultSetCount在resultMaps对应索引位置的ResultMap resultMap，调用handleResultSet,调用getNextResultSet返回值赋值到rsw上，调用cleanUpAfterHandlingResult方法，最后resultSetCount加1。
-   validateResultMapsCount 
   验证ResultMap数量有效。
-   handleResultSet
    入参ResultSetWrapper rsw、ResultMap resultMap、对象列表multipleResults、ResultMapping parentMapping。根据入参情况的不同有着不同的处理不过都是会调用handleRowValues方法，最后会调用closeResultSet方法关闭结果集。如果入参中parentMapping不为null，则会不传入ResultHandler调用handleRowValues。反则进入else判断。如果类属性resultHandler为null，则会构建出DefaultResultHandler实例同类型属性rowBounds作为入参调用handleRowValues，最后把DefaultResultHandler的ResultList添加到multipleResults中。反之直接调用handleRowValues方法传入类属性resultHandler和rowBounds。
-   getNextResultSet
    首先判断入参Statement对应Connection的MetaData调用supportsMultipleResultSets返回为真，
-   handleRowValues
    根据ResultMap是否嵌套ResultMaps方法有两个逻辑分支。如果有则调用ensuresNoRowBounds和checkResultHandler做一些检查确保条件满足，最后调用handlerRowValuesForNestedResultMap。而在另一个分支就简单的调用handleRowValuesForSimpleResultMap。
-   handleRowValuesForNestedResultMap
    调用skipRows完成RowBounds分页跳过offset。
    取previousRowValue的值记为rowValue。
    进入循环处理，循环判定条件为处理ResultSet数量未超过RowBounds的limit限制、ResultSet未关闭、ResultSet存在下一行。调用resolveDiscriminatedResultMap获取Discrimiator决策出ResultMap discriminatedResultMap，调用createRowKey获取CacheKey rowKey。从nestedResultObjects获取rowKey对应的对象partialObject。接下来依据MappedStatement的resultOrdered的状态进入不同处理分支。如果为真进入第一个分支，当partialObject为null且rowValue不为null则清空nestedResultObjects并调用storeObejct，而后调用getRowValue并把返回值赋给rowValue；如果为假则进入第二分支，首先调用getRowValue并把返回值赋给rowValue，当partialiObject为null时调用storeObject。
    最后一步是根据条件进行不同处理，如果rowValue不为nulll、MappedStatement的resultOrdered为真、shouldProcessMoreRows调用返回为真等都成立则先调用storeObeject且将previousRowValue赋为null，反之若rowValue不为null则将previousRowValue赋为rowValue的值。
-   skipRows
    处理RowBounds的分页在ResultSet的取值开始位置，如果ResultSet是TYPE_FORWARD_ONLY类型，则直接循环调用ResultSet.next()至RowBands指定的offset值的次数。而若不是，调用ResultSet的absolute方法。
-   resolveDiscriminatedResultMap
    从ResultMap中获取Discriminator，如果discriminator不为null则进入循环处理，反则直接返回入参ResultMap。
    寻村
-   getDiscriminatorValue
    从discriminator获取ResultMapping，再从resultMapping中获取TypeHandler，通过typeHandler从ResultSet中获取ResultMapping对应列的值。
-   createRowKey
    构建出CacheKey，根据多个因素调用update。ResultMap的id为第一个元素。从调用getResultMappingsForRowKey入参ResultMap中获取ResultMapping列表resultMappings。迭代resultMappings，以每个ResultMapping的名字和数值为因素。最后如果update调用次数小于2则返回NULL_CACHE_KEY，否则返回构建出的cacheKey。
-   storeObject
    如果入参parentMapping不为null，则调用linkToParents，反之调用callResultHandler
-   linkToParents
    调用createKeyForMultipleResults获取CacheKey parentKey，从pendingRelations获取parentKey对应的PendingRelation列表parents。如果parents不为null，则进入对parents的迭代处理中。在循环体中，如果子元素不为null且rowValue不为null，则调用linkObjects，入参为parent.metaObject、parent.propertyMapping、rowValue。
-   linkObjects
    调用instanteCollectionPropertyIfAppropriate方法返回值记为collectionProperty，如果collectionProperty不为null则创建对应MetaObject并添加到targetMetaObject，反之则调用metaObject的setValue将入参rowValue赋值到resultMapping.getProperty属性上。
-   instantiateCollectionPropertyIfAppropriate
    从入参resultMapping获取propertyName，再从metaObject中获取propertyName对应值propertyValue。判断propertyValue是否为null进行不同处理。如果是则创建出新的实例赋值到metaObject上，首先从resultMapping获取javaType type，若type为null则从metaObject中取propertyName的setter的类型，通过objectFactory的isCollection判断后，使用objectFactory的create创建出实例，最后调用metaObject的setValue将propertyValue赋值到propertyName上，返回propertyValue；如果不是通过objectFactory的isCollection判断propertyValue的类型，判断通过则返回propertyValue。若上述两个判断都未返回则默认返回null。
-   callResultHandler
    调用入参resultContext的nextResultObject传入入参rowValue。调用入参resultHandler的handleResult传入入参resultContext。
-   handleRowValuesForSImpleResultMap
    创建DefaultResultCOntext实例记为resultContext，从入参ResultSetWrapper获取ResultSet记为resultSet，调用skipRows处理RoWBounds分页，接下进入循环处理部分。调用shouldProcessMoreRows、resultSet未关闭、resultSet.next等三个方法都为真则进入循环体。循环体内首先调用resolveDIscriminatedResultMap返回值记为discriminatedResultMap，接下来以入参ResultSetWrapper、上步获取的discriminatedResultMap为入参调用getRowValue返回值记为rowValue，最后调用storeObject。
